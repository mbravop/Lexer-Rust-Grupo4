Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AS
    ASYNC
    AWAIT
    BREAK
    CONST
    CONTINUE
    CRATE
    DOUBLEQUOTE
    DYN
    ELSE
    ENUM
    EXTERN
    IF
    IMPL
    LOOP
    MATCH
    MODULE
    MOVE
    PRINT
    PUB
    RETURN
    SINGLEQUOTE
    STATIC
    STRUCT
    SUPER
    Self
    TRAIT
    TYPE
    UNSAFE
    USE
    WHERE
    self

Grammar

Rule 0     S' -> funcion
Rule 1     funcion -> FN ID LPAREN RPAREN LCURLYBRACKET codigo RCURLYBRACKET
Rule 2     codigo -> expresionAritmetica SEMICOLON
Rule 3     codigo -> impresion SEMICOLON
Rule 4     codigo -> condiciones
Rule 5     codigo -> asignacion SEMICOLON
Rule 6     codigo -> estrFor
Rule 7     codigo -> estrWhile
Rule 8     codigo -> input SEMICOLON
Rule 9     codigo -> codigo
Rule 10    expresionAritmetica -> valor operador valor
Rule 11    expresionAritmetica -> valor operador expresionAritmetica
Rule 12    operador -> PLUS
Rule 13    operador -> MINUS
Rule 14    operador -> MULT
Rule 15    operador -> DIVIDE
Rule 16    operador -> MOD
Rule 17    valor -> INTEGER
Rule 18    valor -> FLOAT
Rule 19    valor -> ID
Rule 20    valores -> valor
Rule 21    valores -> valor COMMA valores
Rule 22    impresion -> PRINTLN NOT LPAREN valores RPAREN
Rule 23    impresion -> PRINTLN NOT LPAREN valor RPAREN
Rule 24    input -> STD COLON COLON IO COLON COLON STDIN LPAREN RPAREN DOT READLINE LPAREN REF MUT ID RPAREN
Rule 25    condicion -> valor operComp valor
Rule 26    operComp -> GREATERTHAN
Rule 27    operComp -> LESSTHAN
Rule 28    operComp -> EQUALITY
Rule 29    operComp -> DIFFERENTFROM
Rule 30    operComp -> GREATEREQUALSTHAN
Rule 31    operComp -> LESSEQUALSTHAN
Rule 32    condiciones -> condicion
Rule 33    condiciones -> condicion conector condiciones
Rule 34    condicion -> TRUE
Rule 35    condicion -> FALSE
Rule 36    conector -> AND
Rule 37    conector -> OR
Rule 38    asignacion -> LET ID ASSIGN valor
Rule 39    asignacion -> LET ID ASSIGN condiciones
Rule 40    asignacion -> LET ID ASSIGN expresionAritmetica
Rule 41    asignacion -> LET ID ASSIGN estructuras
Rule 42    estructuras -> tupla
Rule 43    estructuras -> array
Rule 44    tupla -> LPAREN valores RPAREN
Rule 45    tupla -> LPAREN RPAREN
Rule 46    array -> LBRACKET valores RBRACKET
Rule 47    array -> LBRACKET RBRACKET
Rule 48    estrWhile -> WHILE condiciones LCURLYBRACKET codigo RCURLYBRACKET
Rule 49    estrFor -> FOR ID IN ID LCURLYBRACKET codigo RCURLYBRACKET

Terminals, with rules where they appear

AND                  : 36
AS                   : 
ASSIGN               : 38 39 40 41
ASYNC                : 
AWAIT                : 
BREAK                : 
COLON                : 24 24 24 24
COMMA                : 21
CONST                : 
CONTINUE             : 
CRATE                : 
DIFFERENTFROM        : 29
DIVIDE               : 15
DOT                  : 24
DOUBLEQUOTE          : 
DYN                  : 
ELSE                 : 
ENUM                 : 
EQUALITY             : 28
EXTERN               : 
FALSE                : 35
FLOAT                : 18
FN                   : 1
FOR                  : 49
GREATEREQUALSTHAN    : 30
GREATERTHAN          : 26
ID                   : 1 19 24 38 39 40 41 49 49
IF                   : 
IMPL                 : 
IN                   : 49
INTEGER              : 17
IO                   : 24
LBRACKET             : 46 47
LCURLYBRACKET        : 1 48 49
LESSEQUALSTHAN       : 31
LESSTHAN             : 27
LET                  : 38 39 40 41
LOOP                 : 
LPAREN               : 1 22 23 24 24 44 45
MATCH                : 
MINUS                : 13
MOD                  : 16
MODULE               : 
MOVE                 : 
MULT                 : 14
MUT                  : 24
NOT                  : 22 23
OR                   : 37
PLUS                 : 12
PRINT                : 
PRINTLN              : 22 23
PUB                  : 
RBRACKET             : 46 47
RCURLYBRACKET        : 1 48 49
READLINE             : 24
REF                  : 24
RETURN               : 
RPAREN               : 1 22 23 24 24 44 45
SEMICOLON            : 2 3 5 8
SINGLEQUOTE          : 
STATIC               : 
STD                  : 24
STDIN                : 24
STRUCT               : 
SUPER                : 
Self                 : 
TRAIT                : 
TRUE                 : 34
TYPE                 : 
UNSAFE               : 
USE                  : 
WHERE                : 
WHILE                : 48
error                : 
self                 : 

Nonterminals, with rules where they appear

array                : 43
asignacion           : 5
codigo               : 1 9 48 49
condicion            : 32 33
condiciones          : 4 33 39 48
conector             : 33
estrFor              : 6
estrWhile            : 7
estructuras          : 41
expresionAritmetica  : 2 11 40
funcion              : 0
impresion            : 3
input                : 8
operComp             : 25
operador             : 10 11
tupla                : 42
valor                : 10 10 11 20 21 23 25 25 38
valores              : 21 22 44 46

Parsing method: LALR

state 0

    (0) S' -> . funcion
    (1) funcion -> . FN ID LPAREN RPAREN LCURLYBRACKET codigo RCURLYBRACKET

    FN              shift and go to state 2

    funcion                        shift and go to state 1

state 1

    (0) S' -> funcion .



state 2

    (1) funcion -> FN . ID LPAREN RPAREN LCURLYBRACKET codigo RCURLYBRACKET

    ID              shift and go to state 3


state 3

    (1) funcion -> FN ID . LPAREN RPAREN LCURLYBRACKET codigo RCURLYBRACKET

    LPAREN          shift and go to state 4


state 4

    (1) funcion -> FN ID LPAREN . RPAREN LCURLYBRACKET codigo RCURLYBRACKET

    RPAREN          shift and go to state 5


state 5

    (1) funcion -> FN ID LPAREN RPAREN . LCURLYBRACKET codigo RCURLYBRACKET

    LCURLYBRACKET   shift and go to state 6


state 6

    (1) funcion -> FN ID LPAREN RPAREN LCURLYBRACKET . codigo RCURLYBRACKET
    (2) codigo -> . expresionAritmetica SEMICOLON
    (3) codigo -> . impresion SEMICOLON
    (4) codigo -> . condiciones
    (5) codigo -> . asignacion SEMICOLON
    (6) codigo -> . estrFor
    (7) codigo -> . estrWhile
    (8) codigo -> . input SEMICOLON
    (9) codigo -> . codigo
    (10) expresionAritmetica -> . valor operador valor
    (11) expresionAritmetica -> . valor operador expresionAritmetica
    (22) impresion -> . PRINTLN NOT LPAREN valores RPAREN
    (23) impresion -> . PRINTLN NOT LPAREN valor RPAREN
    (32) condiciones -> . condicion
    (33) condiciones -> . condicion conector condiciones
    (38) asignacion -> . LET ID ASSIGN valor
    (39) asignacion -> . LET ID ASSIGN condiciones
    (40) asignacion -> . LET ID ASSIGN expresionAritmetica
    (41) asignacion -> . LET ID ASSIGN estructuras
    (49) estrFor -> . FOR ID IN ID LCURLYBRACKET codigo RCURLYBRACKET
    (48) estrWhile -> . WHILE condiciones LCURLYBRACKET codigo RCURLYBRACKET
    (24) input -> . STD COLON COLON IO COLON COLON STDIN LPAREN RPAREN DOT READLINE LPAREN REF MUT ID RPAREN
    (17) valor -> . INTEGER
    (18) valor -> . FLOAT
    (19) valor -> . ID
    (25) condicion -> . valor operComp valor
    (34) condicion -> . TRUE
    (35) condicion -> . FALSE

    PRINTLN         shift and go to state 17
    LET             shift and go to state 19
    FOR             shift and go to state 20
    WHILE           shift and go to state 21
    STD             shift and go to state 22
    INTEGER         shift and go to state 23
    FLOAT           shift and go to state 24
    ID              shift and go to state 7
    TRUE            shift and go to state 25
    FALSE           shift and go to state 26

    codigo                         shift and go to state 8
    expresionAritmetica            shift and go to state 9
    impresion                      shift and go to state 10
    condiciones                    shift and go to state 11
    asignacion                     shift and go to state 12
    estrFor                        shift and go to state 13
    estrWhile                      shift and go to state 14
    input                          shift and go to state 15
    valor                          shift and go to state 16
    condicion                      shift and go to state 18

state 7

    (19) valor -> ID .

    PLUS            reduce using rule 19 (valor -> ID .)
    MINUS           reduce using rule 19 (valor -> ID .)
    MULT            reduce using rule 19 (valor -> ID .)
    DIVIDE          reduce using rule 19 (valor -> ID .)
    MOD             reduce using rule 19 (valor -> ID .)
    GREATERTHAN     reduce using rule 19 (valor -> ID .)
    LESSTHAN        reduce using rule 19 (valor -> ID .)
    EQUALITY        reduce using rule 19 (valor -> ID .)
    DIFFERENTFROM   reduce using rule 19 (valor -> ID .)
    GREATEREQUALSTHAN reduce using rule 19 (valor -> ID .)
    LESSEQUALSTHAN  reduce using rule 19 (valor -> ID .)
    SEMICOLON       reduce using rule 19 (valor -> ID .)
    AND             reduce using rule 19 (valor -> ID .)
    OR              reduce using rule 19 (valor -> ID .)
    RCURLYBRACKET   reduce using rule 19 (valor -> ID .)
    LCURLYBRACKET   reduce using rule 19 (valor -> ID .)
    RPAREN          reduce using rule 19 (valor -> ID .)
    COMMA           reduce using rule 19 (valor -> ID .)
    RBRACKET        reduce using rule 19 (valor -> ID .)


state 8

    (1) funcion -> FN ID LPAREN RPAREN LCURLYBRACKET codigo . RCURLYBRACKET
    (9) codigo -> codigo .

  ! shift/reduce conflict for RCURLYBRACKET resolved as shift
    RCURLYBRACKET   shift and go to state 27

  ! RCURLYBRACKET   [ reduce using rule 9 (codigo -> codigo .) ]


state 9

    (2) codigo -> expresionAritmetica . SEMICOLON

    SEMICOLON       shift and go to state 28


state 10

    (3) codigo -> impresion . SEMICOLON

    SEMICOLON       shift and go to state 29


state 11

    (4) codigo -> condiciones .

    RCURLYBRACKET   reduce using rule 4 (codigo -> condiciones .)


state 12

    (5) codigo -> asignacion . SEMICOLON

    SEMICOLON       shift and go to state 30


state 13

    (6) codigo -> estrFor .

    RCURLYBRACKET   reduce using rule 6 (codigo -> estrFor .)


state 14

    (7) codigo -> estrWhile .

    RCURLYBRACKET   reduce using rule 7 (codigo -> estrWhile .)


state 15

    (8) codigo -> input . SEMICOLON

    SEMICOLON       shift and go to state 31


state 16

    (10) expresionAritmetica -> valor . operador valor
    (11) expresionAritmetica -> valor . operador expresionAritmetica
    (25) condicion -> valor . operComp valor
    (12) operador -> . PLUS
    (13) operador -> . MINUS
    (14) operador -> . MULT
    (15) operador -> . DIVIDE
    (16) operador -> . MOD
    (26) operComp -> . GREATERTHAN
    (27) operComp -> . LESSTHAN
    (28) operComp -> . EQUALITY
    (29) operComp -> . DIFFERENTFROM
    (30) operComp -> . GREATEREQUALSTHAN
    (31) operComp -> . LESSEQUALSTHAN

    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    MULT            shift and go to state 36
    DIVIDE          shift and go to state 37
    MOD             shift and go to state 38
    GREATERTHAN     shift and go to state 39
    LESSTHAN        shift and go to state 40
    EQUALITY        shift and go to state 41
    DIFFERENTFROM   shift and go to state 42
    GREATEREQUALSTHAN shift and go to state 43
    LESSEQUALSTHAN  shift and go to state 44

    operador                       shift and go to state 32
    operComp                       shift and go to state 33

state 17

    (22) impresion -> PRINTLN . NOT LPAREN valores RPAREN
    (23) impresion -> PRINTLN . NOT LPAREN valor RPAREN

    NOT             shift and go to state 45


state 18

    (32) condiciones -> condicion .
    (33) condiciones -> condicion . conector condiciones
    (36) conector -> . AND
    (37) conector -> . OR

    RCURLYBRACKET   reduce using rule 32 (condiciones -> condicion .)
    LCURLYBRACKET   reduce using rule 32 (condiciones -> condicion .)
    SEMICOLON       reduce using rule 32 (condiciones -> condicion .)
    AND             shift and go to state 47
    OR              shift and go to state 48

    conector                       shift and go to state 46

state 19

    (38) asignacion -> LET . ID ASSIGN valor
    (39) asignacion -> LET . ID ASSIGN condiciones
    (40) asignacion -> LET . ID ASSIGN expresionAritmetica
    (41) asignacion -> LET . ID ASSIGN estructuras

    ID              shift and go to state 49


state 20

    (49) estrFor -> FOR . ID IN ID LCURLYBRACKET codigo RCURLYBRACKET

    ID              shift and go to state 50


state 21

    (48) estrWhile -> WHILE . condiciones LCURLYBRACKET codigo RCURLYBRACKET
    (32) condiciones -> . condicion
    (33) condiciones -> . condicion conector condiciones
    (25) condicion -> . valor operComp valor
    (34) condicion -> . TRUE
    (35) condicion -> . FALSE
    (17) valor -> . INTEGER
    (18) valor -> . FLOAT
    (19) valor -> . ID

    TRUE            shift and go to state 25
    FALSE           shift and go to state 26
    INTEGER         shift and go to state 23
    FLOAT           shift and go to state 24
    ID              shift and go to state 7

    condiciones                    shift and go to state 51
    condicion                      shift and go to state 18
    valor                          shift and go to state 52

state 22

    (24) input -> STD . COLON COLON IO COLON COLON STDIN LPAREN RPAREN DOT READLINE LPAREN REF MUT ID RPAREN

    COLON           shift and go to state 53


state 23

    (17) valor -> INTEGER .

    PLUS            reduce using rule 17 (valor -> INTEGER .)
    MINUS           reduce using rule 17 (valor -> INTEGER .)
    MULT            reduce using rule 17 (valor -> INTEGER .)
    DIVIDE          reduce using rule 17 (valor -> INTEGER .)
    MOD             reduce using rule 17 (valor -> INTEGER .)
    GREATERTHAN     reduce using rule 17 (valor -> INTEGER .)
    LESSTHAN        reduce using rule 17 (valor -> INTEGER .)
    EQUALITY        reduce using rule 17 (valor -> INTEGER .)
    DIFFERENTFROM   reduce using rule 17 (valor -> INTEGER .)
    GREATEREQUALSTHAN reduce using rule 17 (valor -> INTEGER .)
    LESSEQUALSTHAN  reduce using rule 17 (valor -> INTEGER .)
    SEMICOLON       reduce using rule 17 (valor -> INTEGER .)
    AND             reduce using rule 17 (valor -> INTEGER .)
    OR              reduce using rule 17 (valor -> INTEGER .)
    RCURLYBRACKET   reduce using rule 17 (valor -> INTEGER .)
    LCURLYBRACKET   reduce using rule 17 (valor -> INTEGER .)
    RPAREN          reduce using rule 17 (valor -> INTEGER .)
    COMMA           reduce using rule 17 (valor -> INTEGER .)
    RBRACKET        reduce using rule 17 (valor -> INTEGER .)


state 24

    (18) valor -> FLOAT .

    PLUS            reduce using rule 18 (valor -> FLOAT .)
    MINUS           reduce using rule 18 (valor -> FLOAT .)
    MULT            reduce using rule 18 (valor -> FLOAT .)
    DIVIDE          reduce using rule 18 (valor -> FLOAT .)
    MOD             reduce using rule 18 (valor -> FLOAT .)
    GREATERTHAN     reduce using rule 18 (valor -> FLOAT .)
    LESSTHAN        reduce using rule 18 (valor -> FLOAT .)
    EQUALITY        reduce using rule 18 (valor -> FLOAT .)
    DIFFERENTFROM   reduce using rule 18 (valor -> FLOAT .)
    GREATEREQUALSTHAN reduce using rule 18 (valor -> FLOAT .)
    LESSEQUALSTHAN  reduce using rule 18 (valor -> FLOAT .)
    SEMICOLON       reduce using rule 18 (valor -> FLOAT .)
    AND             reduce using rule 18 (valor -> FLOAT .)
    OR              reduce using rule 18 (valor -> FLOAT .)
    RCURLYBRACKET   reduce using rule 18 (valor -> FLOAT .)
    LCURLYBRACKET   reduce using rule 18 (valor -> FLOAT .)
    RPAREN          reduce using rule 18 (valor -> FLOAT .)
    COMMA           reduce using rule 18 (valor -> FLOAT .)
    RBRACKET        reduce using rule 18 (valor -> FLOAT .)


state 25

    (34) condicion -> TRUE .

    AND             reduce using rule 34 (condicion -> TRUE .)
    OR              reduce using rule 34 (condicion -> TRUE .)
    RCURLYBRACKET   reduce using rule 34 (condicion -> TRUE .)
    LCURLYBRACKET   reduce using rule 34 (condicion -> TRUE .)
    SEMICOLON       reduce using rule 34 (condicion -> TRUE .)


state 26

    (35) condicion -> FALSE .

    AND             reduce using rule 35 (condicion -> FALSE .)
    OR              reduce using rule 35 (condicion -> FALSE .)
    RCURLYBRACKET   reduce using rule 35 (condicion -> FALSE .)
    LCURLYBRACKET   reduce using rule 35 (condicion -> FALSE .)
    SEMICOLON       reduce using rule 35 (condicion -> FALSE .)


state 27

    (1) funcion -> FN ID LPAREN RPAREN LCURLYBRACKET codigo RCURLYBRACKET .

    $end            reduce using rule 1 (funcion -> FN ID LPAREN RPAREN LCURLYBRACKET codigo RCURLYBRACKET .)


state 28

    (2) codigo -> expresionAritmetica SEMICOLON .

    RCURLYBRACKET   reduce using rule 2 (codigo -> expresionAritmetica SEMICOLON .)


state 29

    (3) codigo -> impresion SEMICOLON .

    RCURLYBRACKET   reduce using rule 3 (codigo -> impresion SEMICOLON .)


state 30

    (5) codigo -> asignacion SEMICOLON .

    RCURLYBRACKET   reduce using rule 5 (codigo -> asignacion SEMICOLON .)


state 31

    (8) codigo -> input SEMICOLON .

    RCURLYBRACKET   reduce using rule 8 (codigo -> input SEMICOLON .)


state 32

    (10) expresionAritmetica -> valor operador . valor
    (11) expresionAritmetica -> valor operador . expresionAritmetica
    (17) valor -> . INTEGER
    (18) valor -> . FLOAT
    (19) valor -> . ID
    (10) expresionAritmetica -> . valor operador valor
    (11) expresionAritmetica -> . valor operador expresionAritmetica

    INTEGER         shift and go to state 23
    FLOAT           shift and go to state 24
    ID              shift and go to state 7

    valor                          shift and go to state 54
    expresionAritmetica            shift and go to state 55

state 33

    (25) condicion -> valor operComp . valor
    (17) valor -> . INTEGER
    (18) valor -> . FLOAT
    (19) valor -> . ID

    INTEGER         shift and go to state 23
    FLOAT           shift and go to state 24
    ID              shift and go to state 7

    valor                          shift and go to state 56

state 34

    (12) operador -> PLUS .

    INTEGER         reduce using rule 12 (operador -> PLUS .)
    FLOAT           reduce using rule 12 (operador -> PLUS .)
    ID              reduce using rule 12 (operador -> PLUS .)


state 35

    (13) operador -> MINUS .

    INTEGER         reduce using rule 13 (operador -> MINUS .)
    FLOAT           reduce using rule 13 (operador -> MINUS .)
    ID              reduce using rule 13 (operador -> MINUS .)


state 36

    (14) operador -> MULT .

    INTEGER         reduce using rule 14 (operador -> MULT .)
    FLOAT           reduce using rule 14 (operador -> MULT .)
    ID              reduce using rule 14 (operador -> MULT .)


state 37

    (15) operador -> DIVIDE .

    INTEGER         reduce using rule 15 (operador -> DIVIDE .)
    FLOAT           reduce using rule 15 (operador -> DIVIDE .)
    ID              reduce using rule 15 (operador -> DIVIDE .)


state 38

    (16) operador -> MOD .

    INTEGER         reduce using rule 16 (operador -> MOD .)
    FLOAT           reduce using rule 16 (operador -> MOD .)
    ID              reduce using rule 16 (operador -> MOD .)


state 39

    (26) operComp -> GREATERTHAN .

    INTEGER         reduce using rule 26 (operComp -> GREATERTHAN .)
    FLOAT           reduce using rule 26 (operComp -> GREATERTHAN .)
    ID              reduce using rule 26 (operComp -> GREATERTHAN .)


state 40

    (27) operComp -> LESSTHAN .

    INTEGER         reduce using rule 27 (operComp -> LESSTHAN .)
    FLOAT           reduce using rule 27 (operComp -> LESSTHAN .)
    ID              reduce using rule 27 (operComp -> LESSTHAN .)


state 41

    (28) operComp -> EQUALITY .

    INTEGER         reduce using rule 28 (operComp -> EQUALITY .)
    FLOAT           reduce using rule 28 (operComp -> EQUALITY .)
    ID              reduce using rule 28 (operComp -> EQUALITY .)


state 42

    (29) operComp -> DIFFERENTFROM .

    INTEGER         reduce using rule 29 (operComp -> DIFFERENTFROM .)
    FLOAT           reduce using rule 29 (operComp -> DIFFERENTFROM .)
    ID              reduce using rule 29 (operComp -> DIFFERENTFROM .)


state 43

    (30) operComp -> GREATEREQUALSTHAN .

    INTEGER         reduce using rule 30 (operComp -> GREATEREQUALSTHAN .)
    FLOAT           reduce using rule 30 (operComp -> GREATEREQUALSTHAN .)
    ID              reduce using rule 30 (operComp -> GREATEREQUALSTHAN .)


state 44

    (31) operComp -> LESSEQUALSTHAN .

    INTEGER         reduce using rule 31 (operComp -> LESSEQUALSTHAN .)
    FLOAT           reduce using rule 31 (operComp -> LESSEQUALSTHAN .)
    ID              reduce using rule 31 (operComp -> LESSEQUALSTHAN .)


state 45

    (22) impresion -> PRINTLN NOT . LPAREN valores RPAREN
    (23) impresion -> PRINTLN NOT . LPAREN valor RPAREN

    LPAREN          shift and go to state 57


state 46

    (33) condiciones -> condicion conector . condiciones
    (32) condiciones -> . condicion
    (33) condiciones -> . condicion conector condiciones
    (25) condicion -> . valor operComp valor
    (34) condicion -> . TRUE
    (35) condicion -> . FALSE
    (17) valor -> . INTEGER
    (18) valor -> . FLOAT
    (19) valor -> . ID

    TRUE            shift and go to state 25
    FALSE           shift and go to state 26
    INTEGER         shift and go to state 23
    FLOAT           shift and go to state 24
    ID              shift and go to state 7

    condicion                      shift and go to state 18
    condiciones                    shift and go to state 58
    valor                          shift and go to state 52

state 47

    (36) conector -> AND .

    TRUE            reduce using rule 36 (conector -> AND .)
    FALSE           reduce using rule 36 (conector -> AND .)
    INTEGER         reduce using rule 36 (conector -> AND .)
    FLOAT           reduce using rule 36 (conector -> AND .)
    ID              reduce using rule 36 (conector -> AND .)


state 48

    (37) conector -> OR .

    TRUE            reduce using rule 37 (conector -> OR .)
    FALSE           reduce using rule 37 (conector -> OR .)
    INTEGER         reduce using rule 37 (conector -> OR .)
    FLOAT           reduce using rule 37 (conector -> OR .)
    ID              reduce using rule 37 (conector -> OR .)


state 49

    (38) asignacion -> LET ID . ASSIGN valor
    (39) asignacion -> LET ID . ASSIGN condiciones
    (40) asignacion -> LET ID . ASSIGN expresionAritmetica
    (41) asignacion -> LET ID . ASSIGN estructuras

    ASSIGN          shift and go to state 59


state 50

    (49) estrFor -> FOR ID . IN ID LCURLYBRACKET codigo RCURLYBRACKET

    IN              shift and go to state 60


state 51

    (48) estrWhile -> WHILE condiciones . LCURLYBRACKET codigo RCURLYBRACKET

    LCURLYBRACKET   shift and go to state 61


state 52

    (25) condicion -> valor . operComp valor
    (26) operComp -> . GREATERTHAN
    (27) operComp -> . LESSTHAN
    (28) operComp -> . EQUALITY
    (29) operComp -> . DIFFERENTFROM
    (30) operComp -> . GREATEREQUALSTHAN
    (31) operComp -> . LESSEQUALSTHAN

    GREATERTHAN     shift and go to state 39
    LESSTHAN        shift and go to state 40
    EQUALITY        shift and go to state 41
    DIFFERENTFROM   shift and go to state 42
    GREATEREQUALSTHAN shift and go to state 43
    LESSEQUALSTHAN  shift and go to state 44

    operComp                       shift and go to state 33

state 53

    (24) input -> STD COLON . COLON IO COLON COLON STDIN LPAREN RPAREN DOT READLINE LPAREN REF MUT ID RPAREN

    COLON           shift and go to state 62


state 54

    (10) expresionAritmetica -> valor operador valor .
    (10) expresionAritmetica -> valor . operador valor
    (11) expresionAritmetica -> valor . operador expresionAritmetica
    (12) operador -> . PLUS
    (13) operador -> . MINUS
    (14) operador -> . MULT
    (15) operador -> . DIVIDE
    (16) operador -> . MOD

    SEMICOLON       reduce using rule 10 (expresionAritmetica -> valor operador valor .)
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    MULT            shift and go to state 36
    DIVIDE          shift and go to state 37
    MOD             shift and go to state 38

    operador                       shift and go to state 32

state 55

    (11) expresionAritmetica -> valor operador expresionAritmetica .

    SEMICOLON       reduce using rule 11 (expresionAritmetica -> valor operador expresionAritmetica .)


state 56

    (25) condicion -> valor operComp valor .

    AND             reduce using rule 25 (condicion -> valor operComp valor .)
    OR              reduce using rule 25 (condicion -> valor operComp valor .)
    RCURLYBRACKET   reduce using rule 25 (condicion -> valor operComp valor .)
    LCURLYBRACKET   reduce using rule 25 (condicion -> valor operComp valor .)
    SEMICOLON       reduce using rule 25 (condicion -> valor operComp valor .)


state 57

    (22) impresion -> PRINTLN NOT LPAREN . valores RPAREN
    (23) impresion -> PRINTLN NOT LPAREN . valor RPAREN
    (20) valores -> . valor
    (21) valores -> . valor COMMA valores
    (17) valor -> . INTEGER
    (18) valor -> . FLOAT
    (19) valor -> . ID

    INTEGER         shift and go to state 23
    FLOAT           shift and go to state 24
    ID              shift and go to state 7

    valores                        shift and go to state 63
    valor                          shift and go to state 64

state 58

    (33) condiciones -> condicion conector condiciones .

    RCURLYBRACKET   reduce using rule 33 (condiciones -> condicion conector condiciones .)
    LCURLYBRACKET   reduce using rule 33 (condiciones -> condicion conector condiciones .)
    SEMICOLON       reduce using rule 33 (condiciones -> condicion conector condiciones .)


state 59

    (38) asignacion -> LET ID ASSIGN . valor
    (39) asignacion -> LET ID ASSIGN . condiciones
    (40) asignacion -> LET ID ASSIGN . expresionAritmetica
    (41) asignacion -> LET ID ASSIGN . estructuras
    (17) valor -> . INTEGER
    (18) valor -> . FLOAT
    (19) valor -> . ID
    (32) condiciones -> . condicion
    (33) condiciones -> . condicion conector condiciones
    (10) expresionAritmetica -> . valor operador valor
    (11) expresionAritmetica -> . valor operador expresionAritmetica
    (42) estructuras -> . tupla
    (43) estructuras -> . array
    (25) condicion -> . valor operComp valor
    (34) condicion -> . TRUE
    (35) condicion -> . FALSE
    (44) tupla -> . LPAREN valores RPAREN
    (45) tupla -> . LPAREN RPAREN
    (46) array -> . LBRACKET valores RBRACKET
    (47) array -> . LBRACKET RBRACKET

    INTEGER         shift and go to state 23
    FLOAT           shift and go to state 24
    ID              shift and go to state 7
    TRUE            shift and go to state 25
    FALSE           shift and go to state 26
    LPAREN          shift and go to state 71
    LBRACKET        shift and go to state 72

    valor                          shift and go to state 65
    condiciones                    shift and go to state 66
    expresionAritmetica            shift and go to state 67
    estructuras                    shift and go to state 68
    condicion                      shift and go to state 18
    tupla                          shift and go to state 69
    array                          shift and go to state 70

state 60

    (49) estrFor -> FOR ID IN . ID LCURLYBRACKET codigo RCURLYBRACKET

    ID              shift and go to state 73


state 61

    (48) estrWhile -> WHILE condiciones LCURLYBRACKET . codigo RCURLYBRACKET
    (2) codigo -> . expresionAritmetica SEMICOLON
    (3) codigo -> . impresion SEMICOLON
    (4) codigo -> . condiciones
    (5) codigo -> . asignacion SEMICOLON
    (6) codigo -> . estrFor
    (7) codigo -> . estrWhile
    (8) codigo -> . input SEMICOLON
    (9) codigo -> . codigo
    (10) expresionAritmetica -> . valor operador valor
    (11) expresionAritmetica -> . valor operador expresionAritmetica
    (22) impresion -> . PRINTLN NOT LPAREN valores RPAREN
    (23) impresion -> . PRINTLN NOT LPAREN valor RPAREN
    (32) condiciones -> . condicion
    (33) condiciones -> . condicion conector condiciones
    (38) asignacion -> . LET ID ASSIGN valor
    (39) asignacion -> . LET ID ASSIGN condiciones
    (40) asignacion -> . LET ID ASSIGN expresionAritmetica
    (41) asignacion -> . LET ID ASSIGN estructuras
    (49) estrFor -> . FOR ID IN ID LCURLYBRACKET codigo RCURLYBRACKET
    (48) estrWhile -> . WHILE condiciones LCURLYBRACKET codigo RCURLYBRACKET
    (24) input -> . STD COLON COLON IO COLON COLON STDIN LPAREN RPAREN DOT READLINE LPAREN REF MUT ID RPAREN
    (17) valor -> . INTEGER
    (18) valor -> . FLOAT
    (19) valor -> . ID
    (25) condicion -> . valor operComp valor
    (34) condicion -> . TRUE
    (35) condicion -> . FALSE

    PRINTLN         shift and go to state 17
    LET             shift and go to state 19
    FOR             shift and go to state 20
    WHILE           shift and go to state 21
    STD             shift and go to state 22
    INTEGER         shift and go to state 23
    FLOAT           shift and go to state 24
    ID              shift and go to state 7
    TRUE            shift and go to state 25
    FALSE           shift and go to state 26

    condiciones                    shift and go to state 11
    codigo                         shift and go to state 74
    expresionAritmetica            shift and go to state 9
    impresion                      shift and go to state 10
    asignacion                     shift and go to state 12
    estrFor                        shift and go to state 13
    estrWhile                      shift and go to state 14
    input                          shift and go to state 15
    valor                          shift and go to state 16
    condicion                      shift and go to state 18

state 62

    (24) input -> STD COLON COLON . IO COLON COLON STDIN LPAREN RPAREN DOT READLINE LPAREN REF MUT ID RPAREN

    IO              shift and go to state 75


state 63

    (22) impresion -> PRINTLN NOT LPAREN valores . RPAREN

    RPAREN          shift and go to state 76


state 64

    (23) impresion -> PRINTLN NOT LPAREN valor . RPAREN
    (20) valores -> valor .
    (21) valores -> valor . COMMA valores

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 77
    COMMA           shift and go to state 78

  ! RPAREN          [ reduce using rule 20 (valores -> valor .) ]


state 65

    (38) asignacion -> LET ID ASSIGN valor .
    (10) expresionAritmetica -> valor . operador valor
    (11) expresionAritmetica -> valor . operador expresionAritmetica
    (25) condicion -> valor . operComp valor
    (12) operador -> . PLUS
    (13) operador -> . MINUS
    (14) operador -> . MULT
    (15) operador -> . DIVIDE
    (16) operador -> . MOD
    (26) operComp -> . GREATERTHAN
    (27) operComp -> . LESSTHAN
    (28) operComp -> . EQUALITY
    (29) operComp -> . DIFFERENTFROM
    (30) operComp -> . GREATEREQUALSTHAN
    (31) operComp -> . LESSEQUALSTHAN

    SEMICOLON       reduce using rule 38 (asignacion -> LET ID ASSIGN valor .)
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    MULT            shift and go to state 36
    DIVIDE          shift and go to state 37
    MOD             shift and go to state 38
    GREATERTHAN     shift and go to state 39
    LESSTHAN        shift and go to state 40
    EQUALITY        shift and go to state 41
    DIFFERENTFROM   shift and go to state 42
    GREATEREQUALSTHAN shift and go to state 43
    LESSEQUALSTHAN  shift and go to state 44

    operador                       shift and go to state 32
    operComp                       shift and go to state 33

state 66

    (39) asignacion -> LET ID ASSIGN condiciones .

    SEMICOLON       reduce using rule 39 (asignacion -> LET ID ASSIGN condiciones .)


state 67

    (40) asignacion -> LET ID ASSIGN expresionAritmetica .

    SEMICOLON       reduce using rule 40 (asignacion -> LET ID ASSIGN expresionAritmetica .)


state 68

    (41) asignacion -> LET ID ASSIGN estructuras .

    SEMICOLON       reduce using rule 41 (asignacion -> LET ID ASSIGN estructuras .)


state 69

    (42) estructuras -> tupla .

    SEMICOLON       reduce using rule 42 (estructuras -> tupla .)


state 70

    (43) estructuras -> array .

    SEMICOLON       reduce using rule 43 (estructuras -> array .)


state 71

    (44) tupla -> LPAREN . valores RPAREN
    (45) tupla -> LPAREN . RPAREN
    (20) valores -> . valor
    (21) valores -> . valor COMMA valores
    (17) valor -> . INTEGER
    (18) valor -> . FLOAT
    (19) valor -> . ID

    RPAREN          shift and go to state 80
    INTEGER         shift and go to state 23
    FLOAT           shift and go to state 24
    ID              shift and go to state 7

    valores                        shift and go to state 79
    valor                          shift and go to state 81

state 72

    (46) array -> LBRACKET . valores RBRACKET
    (47) array -> LBRACKET . RBRACKET
    (20) valores -> . valor
    (21) valores -> . valor COMMA valores
    (17) valor -> . INTEGER
    (18) valor -> . FLOAT
    (19) valor -> . ID

    RBRACKET        shift and go to state 83
    INTEGER         shift and go to state 23
    FLOAT           shift and go to state 24
    ID              shift and go to state 7

    valores                        shift and go to state 82
    valor                          shift and go to state 81

state 73

    (49) estrFor -> FOR ID IN ID . LCURLYBRACKET codigo RCURLYBRACKET

    LCURLYBRACKET   shift and go to state 84


state 74

    (48) estrWhile -> WHILE condiciones LCURLYBRACKET codigo . RCURLYBRACKET
    (9) codigo -> codigo .

  ! shift/reduce conflict for RCURLYBRACKET resolved as shift
    RCURLYBRACKET   shift and go to state 85

  ! RCURLYBRACKET   [ reduce using rule 9 (codigo -> codigo .) ]


state 75

    (24) input -> STD COLON COLON IO . COLON COLON STDIN LPAREN RPAREN DOT READLINE LPAREN REF MUT ID RPAREN

    COLON           shift and go to state 86


state 76

    (22) impresion -> PRINTLN NOT LPAREN valores RPAREN .

    SEMICOLON       reduce using rule 22 (impresion -> PRINTLN NOT LPAREN valores RPAREN .)


state 77

    (23) impresion -> PRINTLN NOT LPAREN valor RPAREN .

    SEMICOLON       reduce using rule 23 (impresion -> PRINTLN NOT LPAREN valor RPAREN .)


state 78

    (21) valores -> valor COMMA . valores
    (20) valores -> . valor
    (21) valores -> . valor COMMA valores
    (17) valor -> . INTEGER
    (18) valor -> . FLOAT
    (19) valor -> . ID

    INTEGER         shift and go to state 23
    FLOAT           shift and go to state 24
    ID              shift and go to state 7

    valor                          shift and go to state 81
    valores                        shift and go to state 87

state 79

    (44) tupla -> LPAREN valores . RPAREN

    RPAREN          shift and go to state 88


state 80

    (45) tupla -> LPAREN RPAREN .

    SEMICOLON       reduce using rule 45 (tupla -> LPAREN RPAREN .)


state 81

    (20) valores -> valor .
    (21) valores -> valor . COMMA valores

    RPAREN          reduce using rule 20 (valores -> valor .)
    RBRACKET        reduce using rule 20 (valores -> valor .)
    COMMA           shift and go to state 78


state 82

    (46) array -> LBRACKET valores . RBRACKET

    RBRACKET        shift and go to state 89


state 83

    (47) array -> LBRACKET RBRACKET .

    SEMICOLON       reduce using rule 47 (array -> LBRACKET RBRACKET .)


state 84

    (49) estrFor -> FOR ID IN ID LCURLYBRACKET . codigo RCURLYBRACKET
    (2) codigo -> . expresionAritmetica SEMICOLON
    (3) codigo -> . impresion SEMICOLON
    (4) codigo -> . condiciones
    (5) codigo -> . asignacion SEMICOLON
    (6) codigo -> . estrFor
    (7) codigo -> . estrWhile
    (8) codigo -> . input SEMICOLON
    (9) codigo -> . codigo
    (10) expresionAritmetica -> . valor operador valor
    (11) expresionAritmetica -> . valor operador expresionAritmetica
    (22) impresion -> . PRINTLN NOT LPAREN valores RPAREN
    (23) impresion -> . PRINTLN NOT LPAREN valor RPAREN
    (32) condiciones -> . condicion
    (33) condiciones -> . condicion conector condiciones
    (38) asignacion -> . LET ID ASSIGN valor
    (39) asignacion -> . LET ID ASSIGN condiciones
    (40) asignacion -> . LET ID ASSIGN expresionAritmetica
    (41) asignacion -> . LET ID ASSIGN estructuras
    (49) estrFor -> . FOR ID IN ID LCURLYBRACKET codigo RCURLYBRACKET
    (48) estrWhile -> . WHILE condiciones LCURLYBRACKET codigo RCURLYBRACKET
    (24) input -> . STD COLON COLON IO COLON COLON STDIN LPAREN RPAREN DOT READLINE LPAREN REF MUT ID RPAREN
    (17) valor -> . INTEGER
    (18) valor -> . FLOAT
    (19) valor -> . ID
    (25) condicion -> . valor operComp valor
    (34) condicion -> . TRUE
    (35) condicion -> . FALSE

    PRINTLN         shift and go to state 17
    LET             shift and go to state 19
    FOR             shift and go to state 20
    WHILE           shift and go to state 21
    STD             shift and go to state 22
    INTEGER         shift and go to state 23
    FLOAT           shift and go to state 24
    ID              shift and go to state 7
    TRUE            shift and go to state 25
    FALSE           shift and go to state 26

    codigo                         shift and go to state 90
    expresionAritmetica            shift and go to state 9
    impresion                      shift and go to state 10
    condiciones                    shift and go to state 11
    asignacion                     shift and go to state 12
    estrFor                        shift and go to state 13
    estrWhile                      shift and go to state 14
    input                          shift and go to state 15
    valor                          shift and go to state 16
    condicion                      shift and go to state 18

state 85

    (48) estrWhile -> WHILE condiciones LCURLYBRACKET codigo RCURLYBRACKET .

    RCURLYBRACKET   reduce using rule 48 (estrWhile -> WHILE condiciones LCURLYBRACKET codigo RCURLYBRACKET .)


state 86

    (24) input -> STD COLON COLON IO COLON . COLON STDIN LPAREN RPAREN DOT READLINE LPAREN REF MUT ID RPAREN

    COLON           shift and go to state 91


state 87

    (21) valores -> valor COMMA valores .

    RPAREN          reduce using rule 21 (valores -> valor COMMA valores .)
    RBRACKET        reduce using rule 21 (valores -> valor COMMA valores .)


state 88

    (44) tupla -> LPAREN valores RPAREN .

    SEMICOLON       reduce using rule 44 (tupla -> LPAREN valores RPAREN .)


state 89

    (46) array -> LBRACKET valores RBRACKET .

    SEMICOLON       reduce using rule 46 (array -> LBRACKET valores RBRACKET .)


state 90

    (49) estrFor -> FOR ID IN ID LCURLYBRACKET codigo . RCURLYBRACKET
    (9) codigo -> codigo .

  ! shift/reduce conflict for RCURLYBRACKET resolved as shift
    RCURLYBRACKET   shift and go to state 92

  ! RCURLYBRACKET   [ reduce using rule 9 (codigo -> codigo .) ]


state 91

    (24) input -> STD COLON COLON IO COLON COLON . STDIN LPAREN RPAREN DOT READLINE LPAREN REF MUT ID RPAREN

    STDIN           shift and go to state 93


state 92

    (49) estrFor -> FOR ID IN ID LCURLYBRACKET codigo RCURLYBRACKET .

    RCURLYBRACKET   reduce using rule 49 (estrFor -> FOR ID IN ID LCURLYBRACKET codigo RCURLYBRACKET .)


state 93

    (24) input -> STD COLON COLON IO COLON COLON STDIN . LPAREN RPAREN DOT READLINE LPAREN REF MUT ID RPAREN

    LPAREN          shift and go to state 94


state 94

    (24) input -> STD COLON COLON IO COLON COLON STDIN LPAREN . RPAREN DOT READLINE LPAREN REF MUT ID RPAREN

    RPAREN          shift and go to state 95


state 95

    (24) input -> STD COLON COLON IO COLON COLON STDIN LPAREN RPAREN . DOT READLINE LPAREN REF MUT ID RPAREN

    DOT             shift and go to state 96


state 96

    (24) input -> STD COLON COLON IO COLON COLON STDIN LPAREN RPAREN DOT . READLINE LPAREN REF MUT ID RPAREN

    READLINE        shift and go to state 97


state 97

    (24) input -> STD COLON COLON IO COLON COLON STDIN LPAREN RPAREN DOT READLINE . LPAREN REF MUT ID RPAREN

    LPAREN          shift and go to state 98


state 98

    (24) input -> STD COLON COLON IO COLON COLON STDIN LPAREN RPAREN DOT READLINE LPAREN . REF MUT ID RPAREN

    REF             shift and go to state 99


state 99

    (24) input -> STD COLON COLON IO COLON COLON STDIN LPAREN RPAREN DOT READLINE LPAREN REF . MUT ID RPAREN

    MUT             shift and go to state 100


state 100

    (24) input -> STD COLON COLON IO COLON COLON STDIN LPAREN RPAREN DOT READLINE LPAREN REF MUT . ID RPAREN

    ID              shift and go to state 101


state 101

    (24) input -> STD COLON COLON IO COLON COLON STDIN LPAREN RPAREN DOT READLINE LPAREN REF MUT ID . RPAREN

    RPAREN          shift and go to state 102


state 102

    (24) input -> STD COLON COLON IO COLON COLON STDIN LPAREN RPAREN DOT READLINE LPAREN REF MUT ID RPAREN .

    SEMICOLON       reduce using rule 24 (input -> STD COLON COLON IO COLON COLON STDIN LPAREN RPAREN DOT READLINE LPAREN REF MUT ID RPAREN .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for RCURLYBRACKET in state 8 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 64 resolved as shift
WARNING: shift/reduce conflict for RCURLYBRACKET in state 74 resolved as shift
WARNING: shift/reduce conflict for RCURLYBRACKET in state 90 resolved as shift
