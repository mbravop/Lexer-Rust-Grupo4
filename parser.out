Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AS
    ASYNC
    AWAIT
    BREAK
    COLON
    CONST
    CONTINUE
    CRATE
    DOUBLEQUOTE
    DYN
    ELSE
    ENUM
    EXTERN
    FN
    IF
    IMPL
    LET
    LOOP
    MATCH
    MODULE
    MOVE
    PRINT
    PUB
    RETURN
    SINGLEQUOTE
    STATIC
    STRUCT
    SUPER
    Self
    TRAIT
    TYPE
    UNSAFE
    USE
    WHERE
    self

Grammar

Rule 0     S' -> codigo
Rule 1     codigo -> expresionAritmetica SEMICOLON
Rule 2     codigo -> impresion SEMICOLON
Rule 3     codigo -> condiciones SEMICOLON
Rule 4     codigo -> asignacion SEMICOLON
Rule 5     codigo -> estrFor
Rule 6     codigo -> estrWhile
Rule 7     codigo -> input SEMICOLON
Rule 8     expresionAritmetica -> valor operador valor
Rule 9     expresionAritmetica -> valor operador expresionAritmetica
Rule 10    operador -> PLUS
Rule 11    operador -> MINUS
Rule 12    operador -> MULT
Rule 13    operador -> DIVIDE
Rule 14    operador -> MOD
Rule 15    valor -> INTEGER
Rule 16    valor -> FLOAT
Rule 17    valor -> ID
Rule 18    valores -> valor
Rule 19    valores -> valor COMMA valores
Rule 20    impresion -> PRINTLN NOT LPAREN valores RPAREN
Rule 21    impresion -> PRINTLN NOT LPAREN valor RPAREN
Rule 22    input -> STD DOUBLECOLON IO DOUBLECOLON STDIN LPAREN RPAREN DOT READLINE LPAREN REF MUT ID RPAREN
Rule 23    condicion -> valor operComp valor
Rule 24    operComp -> GREATERTHAN
Rule 25    operComp -> LESSTHAN
Rule 26    operComp -> EQUALITY
Rule 27    operComp -> DIFFERENTFROM
Rule 28    operComp -> GREATEREQUALSTHAN
Rule 29    operComp -> LESSEQUALSTHAN
Rule 30    condiciones -> condicion
Rule 31    condiciones -> condicion conector condiciones
Rule 32    condicion -> TRUE
Rule 33    condicion -> FALSE
Rule 34    conector -> AND
Rule 35    conector -> OR
Rule 36    asignacion -> ID ASSIGN valor
Rule 37    asignacion -> ID ASSIGN condiciones
Rule 38    asignacion -> ID ASSIGN expresionAritmetica
Rule 39    asignacion -> ID ASSIGN estructuras
Rule 40    estructuras -> tupla
Rule 41    estructuras -> array
Rule 42    tupla -> LPAREN valores RPAREN
Rule 43    tupla -> LPAREN RPAREN
Rule 44    array -> LBRACKET valores RBRACKET
Rule 45    array -> LBRACKET RBRACKET
Rule 46    estrWhile -> WHILE condiciones LCURLYBRACKET codigo RCURLYBRACKET
Rule 47    estrFor -> FOR ID IN ID LCURLYBRACKET codigo RCURLYBRACKET

Terminals, with rules where they appear

AND                  : 34
AS                   : 
ASSIGN               : 36 37 38 39
ASYNC                : 
AWAIT                : 
BREAK                : 
COLON                : 
COMMA                : 19
CONST                : 
CONTINUE             : 
CRATE                : 
DIFFERENTFROM        : 27
DIVIDE               : 13
DOT                  : 22
DOUBLECOLON          : 22 22
DOUBLEQUOTE          : 
DYN                  : 
ELSE                 : 
ENUM                 : 
EQUALITY             : 26
EXTERN               : 
FALSE                : 33
FLOAT                : 16
FN                   : 
FOR                  : 47
GREATEREQUALSTHAN    : 28
GREATERTHAN          : 24
ID                   : 17 22 36 37 38 39 47 47
IF                   : 
IMPL                 : 
IN                   : 47
INTEGER              : 15
IO                   : 22
LBRACKET             : 44 45
LCURLYBRACKET        : 46 47
LESSEQUALSTHAN       : 29
LESSTHAN             : 25
LET                  : 
LOOP                 : 
LPAREN               : 20 21 22 22 42 43
MATCH                : 
MINUS                : 11
MOD                  : 14
MODULE               : 
MOVE                 : 
MULT                 : 12
MUT                  : 22
NOT                  : 20 21
OR                   : 35
PLUS                 : 10
PRINT                : 
PRINTLN              : 20 21
PUB                  : 
RBRACKET             : 44 45
RCURLYBRACKET        : 46 47
READLINE             : 22
REF                  : 22
RETURN               : 
RPAREN               : 20 21 22 22 42 43
SEMICOLON            : 1 2 3 4 7
SINGLEQUOTE          : 
STATIC               : 
STD                  : 22
STDIN                : 22
STRUCT               : 
SUPER                : 
Self                 : 
TRAIT                : 
TRUE                 : 32
TYPE                 : 
UNSAFE               : 
USE                  : 
WHERE                : 
WHILE                : 46
error                : 
self                 : 

Nonterminals, with rules where they appear

array                : 41
asignacion           : 4
codigo               : 46 47 0
condicion            : 30 31
condiciones          : 3 31 37 46
conector             : 31
estrFor              : 5
estrWhile            : 6
estructuras          : 39
expresionAritmetica  : 1 9 38
impresion            : 2
input                : 7
operComp             : 23
operador             : 8 9
tupla                : 40
valor                : 8 8 9 18 19 21 23 23 36
valores              : 19 20 42 44

Parsing method: LALR

state 0

    (0) S' -> . codigo
    (1) codigo -> . expresionAritmetica SEMICOLON
    (2) codigo -> . impresion SEMICOLON
    (3) codigo -> . condiciones SEMICOLON
    (4) codigo -> . asignacion SEMICOLON
    (5) codigo -> . estrFor
    (6) codigo -> . estrWhile
    (7) codigo -> . input SEMICOLON
    (8) expresionAritmetica -> . valor operador valor
    (9) expresionAritmetica -> . valor operador expresionAritmetica
    (20) impresion -> . PRINTLN NOT LPAREN valores RPAREN
    (21) impresion -> . PRINTLN NOT LPAREN valor RPAREN
    (30) condiciones -> . condicion
    (31) condiciones -> . condicion conector condiciones
    (36) asignacion -> . ID ASSIGN valor
    (37) asignacion -> . ID ASSIGN condiciones
    (38) asignacion -> . ID ASSIGN expresionAritmetica
    (39) asignacion -> . ID ASSIGN estructuras
    (47) estrFor -> . FOR ID IN ID LCURLYBRACKET codigo RCURLYBRACKET
    (46) estrWhile -> . WHILE condiciones LCURLYBRACKET codigo RCURLYBRACKET
    (22) input -> . STD DOUBLECOLON IO DOUBLECOLON STDIN LPAREN RPAREN DOT READLINE LPAREN REF MUT ID RPAREN
    (15) valor -> . INTEGER
    (16) valor -> . FLOAT
    (17) valor -> . ID
    (23) condicion -> . valor operComp valor
    (32) condicion -> . TRUE
    (33) condicion -> . FALSE

    PRINTLN         shift and go to state 10
    ID              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    STD             shift and go to state 15
    INTEGER         shift and go to state 16
    FLOAT           shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19

    codigo                         shift and go to state 1
    expresionAritmetica            shift and go to state 2
    impresion                      shift and go to state 3
    condiciones                    shift and go to state 4
    asignacion                     shift and go to state 5
    estrFor                        shift and go to state 6
    estrWhile                      shift and go to state 7
    input                          shift and go to state 8
    valor                          shift and go to state 9
    condicion                      shift and go to state 11

state 1

    (0) S' -> codigo .



state 2

    (1) codigo -> expresionAritmetica . SEMICOLON

    SEMICOLON       shift and go to state 20


state 3

    (2) codigo -> impresion . SEMICOLON

    SEMICOLON       shift and go to state 21


state 4

    (3) codigo -> condiciones . SEMICOLON

    SEMICOLON       shift and go to state 22


state 5

    (4) codigo -> asignacion . SEMICOLON

    SEMICOLON       shift and go to state 23


state 6

    (5) codigo -> estrFor .

    $end            reduce using rule 5 (codigo -> estrFor .)
    RCURLYBRACKET   reduce using rule 5 (codigo -> estrFor .)


state 7

    (6) codigo -> estrWhile .

    $end            reduce using rule 6 (codigo -> estrWhile .)
    RCURLYBRACKET   reduce using rule 6 (codigo -> estrWhile .)


state 8

    (7) codigo -> input . SEMICOLON

    SEMICOLON       shift and go to state 24


state 9

    (8) expresionAritmetica -> valor . operador valor
    (9) expresionAritmetica -> valor . operador expresionAritmetica
    (23) condicion -> valor . operComp valor
    (10) operador -> . PLUS
    (11) operador -> . MINUS
    (12) operador -> . MULT
    (13) operador -> . DIVIDE
    (14) operador -> . MOD
    (24) operComp -> . GREATERTHAN
    (25) operComp -> . LESSTHAN
    (26) operComp -> . EQUALITY
    (27) operComp -> . DIFFERENTFROM
    (28) operComp -> . GREATEREQUALSTHAN
    (29) operComp -> . LESSEQUALSTHAN

    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    MULT            shift and go to state 29
    DIVIDE          shift and go to state 30
    MOD             shift and go to state 31
    GREATERTHAN     shift and go to state 32
    LESSTHAN        shift and go to state 33
    EQUALITY        shift and go to state 34
    DIFFERENTFROM   shift and go to state 35
    GREATEREQUALSTHAN shift and go to state 36
    LESSEQUALSTHAN  shift and go to state 37

    operador                       shift and go to state 25
    operComp                       shift and go to state 26

state 10

    (20) impresion -> PRINTLN . NOT LPAREN valores RPAREN
    (21) impresion -> PRINTLN . NOT LPAREN valor RPAREN

    NOT             shift and go to state 38


state 11

    (30) condiciones -> condicion .
    (31) condiciones -> condicion . conector condiciones
    (34) conector -> . AND
    (35) conector -> . OR

    SEMICOLON       reduce using rule 30 (condiciones -> condicion .)
    LCURLYBRACKET   reduce using rule 30 (condiciones -> condicion .)
    AND             shift and go to state 40
    OR              shift and go to state 41

    conector                       shift and go to state 39

state 12

    (36) asignacion -> ID . ASSIGN valor
    (37) asignacion -> ID . ASSIGN condiciones
    (38) asignacion -> ID . ASSIGN expresionAritmetica
    (39) asignacion -> ID . ASSIGN estructuras
    (17) valor -> ID .

    ASSIGN          shift and go to state 42
    PLUS            reduce using rule 17 (valor -> ID .)
    MINUS           reduce using rule 17 (valor -> ID .)
    MULT            reduce using rule 17 (valor -> ID .)
    DIVIDE          reduce using rule 17 (valor -> ID .)
    MOD             reduce using rule 17 (valor -> ID .)
    GREATERTHAN     reduce using rule 17 (valor -> ID .)
    LESSTHAN        reduce using rule 17 (valor -> ID .)
    EQUALITY        reduce using rule 17 (valor -> ID .)
    DIFFERENTFROM   reduce using rule 17 (valor -> ID .)
    GREATEREQUALSTHAN reduce using rule 17 (valor -> ID .)
    LESSEQUALSTHAN  reduce using rule 17 (valor -> ID .)


state 13

    (47) estrFor -> FOR . ID IN ID LCURLYBRACKET codigo RCURLYBRACKET

    ID              shift and go to state 43


state 14

    (46) estrWhile -> WHILE . condiciones LCURLYBRACKET codigo RCURLYBRACKET
    (30) condiciones -> . condicion
    (31) condiciones -> . condicion conector condiciones
    (23) condicion -> . valor operComp valor
    (32) condicion -> . TRUE
    (33) condicion -> . FALSE
    (15) valor -> . INTEGER
    (16) valor -> . FLOAT
    (17) valor -> . ID

    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    INTEGER         shift and go to state 16
    FLOAT           shift and go to state 17
    ID              shift and go to state 46

    condiciones                    shift and go to state 44
    condicion                      shift and go to state 11
    valor                          shift and go to state 45

state 15

    (22) input -> STD . DOUBLECOLON IO DOUBLECOLON STDIN LPAREN RPAREN DOT READLINE LPAREN REF MUT ID RPAREN

    DOUBLECOLON     shift and go to state 47


state 16

    (15) valor -> INTEGER .

    PLUS            reduce using rule 15 (valor -> INTEGER .)
    MINUS           reduce using rule 15 (valor -> INTEGER .)
    MULT            reduce using rule 15 (valor -> INTEGER .)
    DIVIDE          reduce using rule 15 (valor -> INTEGER .)
    MOD             reduce using rule 15 (valor -> INTEGER .)
    GREATERTHAN     reduce using rule 15 (valor -> INTEGER .)
    LESSTHAN        reduce using rule 15 (valor -> INTEGER .)
    EQUALITY        reduce using rule 15 (valor -> INTEGER .)
    DIFFERENTFROM   reduce using rule 15 (valor -> INTEGER .)
    GREATEREQUALSTHAN reduce using rule 15 (valor -> INTEGER .)
    LESSEQUALSTHAN  reduce using rule 15 (valor -> INTEGER .)
    SEMICOLON       reduce using rule 15 (valor -> INTEGER .)
    AND             reduce using rule 15 (valor -> INTEGER .)
    OR              reduce using rule 15 (valor -> INTEGER .)
    LCURLYBRACKET   reduce using rule 15 (valor -> INTEGER .)
    RPAREN          reduce using rule 15 (valor -> INTEGER .)
    COMMA           reduce using rule 15 (valor -> INTEGER .)
    RBRACKET        reduce using rule 15 (valor -> INTEGER .)


state 17

    (16) valor -> FLOAT .

    PLUS            reduce using rule 16 (valor -> FLOAT .)
    MINUS           reduce using rule 16 (valor -> FLOAT .)
    MULT            reduce using rule 16 (valor -> FLOAT .)
    DIVIDE          reduce using rule 16 (valor -> FLOAT .)
    MOD             reduce using rule 16 (valor -> FLOAT .)
    GREATERTHAN     reduce using rule 16 (valor -> FLOAT .)
    LESSTHAN        reduce using rule 16 (valor -> FLOAT .)
    EQUALITY        reduce using rule 16 (valor -> FLOAT .)
    DIFFERENTFROM   reduce using rule 16 (valor -> FLOAT .)
    GREATEREQUALSTHAN reduce using rule 16 (valor -> FLOAT .)
    LESSEQUALSTHAN  reduce using rule 16 (valor -> FLOAT .)
    SEMICOLON       reduce using rule 16 (valor -> FLOAT .)
    AND             reduce using rule 16 (valor -> FLOAT .)
    OR              reduce using rule 16 (valor -> FLOAT .)
    LCURLYBRACKET   reduce using rule 16 (valor -> FLOAT .)
    RPAREN          reduce using rule 16 (valor -> FLOAT .)
    COMMA           reduce using rule 16 (valor -> FLOAT .)
    RBRACKET        reduce using rule 16 (valor -> FLOAT .)


state 18

    (32) condicion -> TRUE .

    AND             reduce using rule 32 (condicion -> TRUE .)
    OR              reduce using rule 32 (condicion -> TRUE .)
    SEMICOLON       reduce using rule 32 (condicion -> TRUE .)
    LCURLYBRACKET   reduce using rule 32 (condicion -> TRUE .)


state 19

    (33) condicion -> FALSE .

    AND             reduce using rule 33 (condicion -> FALSE .)
    OR              reduce using rule 33 (condicion -> FALSE .)
    SEMICOLON       reduce using rule 33 (condicion -> FALSE .)
    LCURLYBRACKET   reduce using rule 33 (condicion -> FALSE .)


state 20

    (1) codigo -> expresionAritmetica SEMICOLON .

    $end            reduce using rule 1 (codigo -> expresionAritmetica SEMICOLON .)
    RCURLYBRACKET   reduce using rule 1 (codigo -> expresionAritmetica SEMICOLON .)


state 21

    (2) codigo -> impresion SEMICOLON .

    $end            reduce using rule 2 (codigo -> impresion SEMICOLON .)
    RCURLYBRACKET   reduce using rule 2 (codigo -> impresion SEMICOLON .)


state 22

    (3) codigo -> condiciones SEMICOLON .

    $end            reduce using rule 3 (codigo -> condiciones SEMICOLON .)
    RCURLYBRACKET   reduce using rule 3 (codigo -> condiciones SEMICOLON .)


state 23

    (4) codigo -> asignacion SEMICOLON .

    $end            reduce using rule 4 (codigo -> asignacion SEMICOLON .)
    RCURLYBRACKET   reduce using rule 4 (codigo -> asignacion SEMICOLON .)


state 24

    (7) codigo -> input SEMICOLON .

    $end            reduce using rule 7 (codigo -> input SEMICOLON .)
    RCURLYBRACKET   reduce using rule 7 (codigo -> input SEMICOLON .)


state 25

    (8) expresionAritmetica -> valor operador . valor
    (9) expresionAritmetica -> valor operador . expresionAritmetica
    (15) valor -> . INTEGER
    (16) valor -> . FLOAT
    (17) valor -> . ID
    (8) expresionAritmetica -> . valor operador valor
    (9) expresionAritmetica -> . valor operador expresionAritmetica

    INTEGER         shift and go to state 16
    FLOAT           shift and go to state 17
    ID              shift and go to state 46

    valor                          shift and go to state 48
    expresionAritmetica            shift and go to state 49

state 26

    (23) condicion -> valor operComp . valor
    (15) valor -> . INTEGER
    (16) valor -> . FLOAT
    (17) valor -> . ID

    INTEGER         shift and go to state 16
    FLOAT           shift and go to state 17
    ID              shift and go to state 46

    valor                          shift and go to state 50

state 27

    (10) operador -> PLUS .

    INTEGER         reduce using rule 10 (operador -> PLUS .)
    FLOAT           reduce using rule 10 (operador -> PLUS .)
    ID              reduce using rule 10 (operador -> PLUS .)


state 28

    (11) operador -> MINUS .

    INTEGER         reduce using rule 11 (operador -> MINUS .)
    FLOAT           reduce using rule 11 (operador -> MINUS .)
    ID              reduce using rule 11 (operador -> MINUS .)


state 29

    (12) operador -> MULT .

    INTEGER         reduce using rule 12 (operador -> MULT .)
    FLOAT           reduce using rule 12 (operador -> MULT .)
    ID              reduce using rule 12 (operador -> MULT .)


state 30

    (13) operador -> DIVIDE .

    INTEGER         reduce using rule 13 (operador -> DIVIDE .)
    FLOAT           reduce using rule 13 (operador -> DIVIDE .)
    ID              reduce using rule 13 (operador -> DIVIDE .)


state 31

    (14) operador -> MOD .

    INTEGER         reduce using rule 14 (operador -> MOD .)
    FLOAT           reduce using rule 14 (operador -> MOD .)
    ID              reduce using rule 14 (operador -> MOD .)


state 32

    (24) operComp -> GREATERTHAN .

    INTEGER         reduce using rule 24 (operComp -> GREATERTHAN .)
    FLOAT           reduce using rule 24 (operComp -> GREATERTHAN .)
    ID              reduce using rule 24 (operComp -> GREATERTHAN .)


state 33

    (25) operComp -> LESSTHAN .

    INTEGER         reduce using rule 25 (operComp -> LESSTHAN .)
    FLOAT           reduce using rule 25 (operComp -> LESSTHAN .)
    ID              reduce using rule 25 (operComp -> LESSTHAN .)


state 34

    (26) operComp -> EQUALITY .

    INTEGER         reduce using rule 26 (operComp -> EQUALITY .)
    FLOAT           reduce using rule 26 (operComp -> EQUALITY .)
    ID              reduce using rule 26 (operComp -> EQUALITY .)


state 35

    (27) operComp -> DIFFERENTFROM .

    INTEGER         reduce using rule 27 (operComp -> DIFFERENTFROM .)
    FLOAT           reduce using rule 27 (operComp -> DIFFERENTFROM .)
    ID              reduce using rule 27 (operComp -> DIFFERENTFROM .)


state 36

    (28) operComp -> GREATEREQUALSTHAN .

    INTEGER         reduce using rule 28 (operComp -> GREATEREQUALSTHAN .)
    FLOAT           reduce using rule 28 (operComp -> GREATEREQUALSTHAN .)
    ID              reduce using rule 28 (operComp -> GREATEREQUALSTHAN .)


state 37

    (29) operComp -> LESSEQUALSTHAN .

    INTEGER         reduce using rule 29 (operComp -> LESSEQUALSTHAN .)
    FLOAT           reduce using rule 29 (operComp -> LESSEQUALSTHAN .)
    ID              reduce using rule 29 (operComp -> LESSEQUALSTHAN .)


state 38

    (20) impresion -> PRINTLN NOT . LPAREN valores RPAREN
    (21) impresion -> PRINTLN NOT . LPAREN valor RPAREN

    LPAREN          shift and go to state 51


state 39

    (31) condiciones -> condicion conector . condiciones
    (30) condiciones -> . condicion
    (31) condiciones -> . condicion conector condiciones
    (23) condicion -> . valor operComp valor
    (32) condicion -> . TRUE
    (33) condicion -> . FALSE
    (15) valor -> . INTEGER
    (16) valor -> . FLOAT
    (17) valor -> . ID

    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    INTEGER         shift and go to state 16
    FLOAT           shift and go to state 17
    ID              shift and go to state 46

    condicion                      shift and go to state 11
    condiciones                    shift and go to state 52
    valor                          shift and go to state 45

state 40

    (34) conector -> AND .

    TRUE            reduce using rule 34 (conector -> AND .)
    FALSE           reduce using rule 34 (conector -> AND .)
    INTEGER         reduce using rule 34 (conector -> AND .)
    FLOAT           reduce using rule 34 (conector -> AND .)
    ID              reduce using rule 34 (conector -> AND .)


state 41

    (35) conector -> OR .

    TRUE            reduce using rule 35 (conector -> OR .)
    FALSE           reduce using rule 35 (conector -> OR .)
    INTEGER         reduce using rule 35 (conector -> OR .)
    FLOAT           reduce using rule 35 (conector -> OR .)
    ID              reduce using rule 35 (conector -> OR .)


state 42

    (36) asignacion -> ID ASSIGN . valor
    (37) asignacion -> ID ASSIGN . condiciones
    (38) asignacion -> ID ASSIGN . expresionAritmetica
    (39) asignacion -> ID ASSIGN . estructuras
    (15) valor -> . INTEGER
    (16) valor -> . FLOAT
    (17) valor -> . ID
    (30) condiciones -> . condicion
    (31) condiciones -> . condicion conector condiciones
    (8) expresionAritmetica -> . valor operador valor
    (9) expresionAritmetica -> . valor operador expresionAritmetica
    (40) estructuras -> . tupla
    (41) estructuras -> . array
    (23) condicion -> . valor operComp valor
    (32) condicion -> . TRUE
    (33) condicion -> . FALSE
    (42) tupla -> . LPAREN valores RPAREN
    (43) tupla -> . LPAREN RPAREN
    (44) array -> . LBRACKET valores RBRACKET
    (45) array -> . LBRACKET RBRACKET

    INTEGER         shift and go to state 16
    FLOAT           shift and go to state 17
    ID              shift and go to state 46
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    LPAREN          shift and go to state 59
    LBRACKET        shift and go to state 60

    valor                          shift and go to state 53
    condiciones                    shift and go to state 54
    expresionAritmetica            shift and go to state 55
    estructuras                    shift and go to state 56
    condicion                      shift and go to state 11
    tupla                          shift and go to state 57
    array                          shift and go to state 58

state 43

    (47) estrFor -> FOR ID . IN ID LCURLYBRACKET codigo RCURLYBRACKET

    IN              shift and go to state 61


state 44

    (46) estrWhile -> WHILE condiciones . LCURLYBRACKET codigo RCURLYBRACKET

    LCURLYBRACKET   shift and go to state 62


state 45

    (23) condicion -> valor . operComp valor
    (24) operComp -> . GREATERTHAN
    (25) operComp -> . LESSTHAN
    (26) operComp -> . EQUALITY
    (27) operComp -> . DIFFERENTFROM
    (28) operComp -> . GREATEREQUALSTHAN
    (29) operComp -> . LESSEQUALSTHAN

    GREATERTHAN     shift and go to state 32
    LESSTHAN        shift and go to state 33
    EQUALITY        shift and go to state 34
    DIFFERENTFROM   shift and go to state 35
    GREATEREQUALSTHAN shift and go to state 36
    LESSEQUALSTHAN  shift and go to state 37

    operComp                       shift and go to state 26

state 46

    (17) valor -> ID .

    GREATERTHAN     reduce using rule 17 (valor -> ID .)
    LESSTHAN        reduce using rule 17 (valor -> ID .)
    EQUALITY        reduce using rule 17 (valor -> ID .)
    DIFFERENTFROM   reduce using rule 17 (valor -> ID .)
    GREATEREQUALSTHAN reduce using rule 17 (valor -> ID .)
    LESSEQUALSTHAN  reduce using rule 17 (valor -> ID .)
    PLUS            reduce using rule 17 (valor -> ID .)
    MINUS           reduce using rule 17 (valor -> ID .)
    MULT            reduce using rule 17 (valor -> ID .)
    DIVIDE          reduce using rule 17 (valor -> ID .)
    MOD             reduce using rule 17 (valor -> ID .)
    SEMICOLON       reduce using rule 17 (valor -> ID .)
    AND             reduce using rule 17 (valor -> ID .)
    OR              reduce using rule 17 (valor -> ID .)
    LCURLYBRACKET   reduce using rule 17 (valor -> ID .)
    RPAREN          reduce using rule 17 (valor -> ID .)
    COMMA           reduce using rule 17 (valor -> ID .)
    RBRACKET        reduce using rule 17 (valor -> ID .)


state 47

    (22) input -> STD DOUBLECOLON . IO DOUBLECOLON STDIN LPAREN RPAREN DOT READLINE LPAREN REF MUT ID RPAREN

    IO              shift and go to state 63


state 48

    (8) expresionAritmetica -> valor operador valor .
    (8) expresionAritmetica -> valor . operador valor
    (9) expresionAritmetica -> valor . operador expresionAritmetica
    (10) operador -> . PLUS
    (11) operador -> . MINUS
    (12) operador -> . MULT
    (13) operador -> . DIVIDE
    (14) operador -> . MOD

    SEMICOLON       reduce using rule 8 (expresionAritmetica -> valor operador valor .)
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    MULT            shift and go to state 29
    DIVIDE          shift and go to state 30
    MOD             shift and go to state 31

    operador                       shift and go to state 25

state 49

    (9) expresionAritmetica -> valor operador expresionAritmetica .

    SEMICOLON       reduce using rule 9 (expresionAritmetica -> valor operador expresionAritmetica .)


state 50

    (23) condicion -> valor operComp valor .

    AND             reduce using rule 23 (condicion -> valor operComp valor .)
    OR              reduce using rule 23 (condicion -> valor operComp valor .)
    SEMICOLON       reduce using rule 23 (condicion -> valor operComp valor .)
    LCURLYBRACKET   reduce using rule 23 (condicion -> valor operComp valor .)


state 51

    (20) impresion -> PRINTLN NOT LPAREN . valores RPAREN
    (21) impresion -> PRINTLN NOT LPAREN . valor RPAREN
    (18) valores -> . valor
    (19) valores -> . valor COMMA valores
    (15) valor -> . INTEGER
    (16) valor -> . FLOAT
    (17) valor -> . ID

    INTEGER         shift and go to state 16
    FLOAT           shift and go to state 17
    ID              shift and go to state 46

    valores                        shift and go to state 64
    valor                          shift and go to state 65

state 52

    (31) condiciones -> condicion conector condiciones .

    SEMICOLON       reduce using rule 31 (condiciones -> condicion conector condiciones .)
    LCURLYBRACKET   reduce using rule 31 (condiciones -> condicion conector condiciones .)


state 53

    (36) asignacion -> ID ASSIGN valor .
    (8) expresionAritmetica -> valor . operador valor
    (9) expresionAritmetica -> valor . operador expresionAritmetica
    (23) condicion -> valor . operComp valor
    (10) operador -> . PLUS
    (11) operador -> . MINUS
    (12) operador -> . MULT
    (13) operador -> . DIVIDE
    (14) operador -> . MOD
    (24) operComp -> . GREATERTHAN
    (25) operComp -> . LESSTHAN
    (26) operComp -> . EQUALITY
    (27) operComp -> . DIFFERENTFROM
    (28) operComp -> . GREATEREQUALSTHAN
    (29) operComp -> . LESSEQUALSTHAN

    SEMICOLON       reduce using rule 36 (asignacion -> ID ASSIGN valor .)
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    MULT            shift and go to state 29
    DIVIDE          shift and go to state 30
    MOD             shift and go to state 31
    GREATERTHAN     shift and go to state 32
    LESSTHAN        shift and go to state 33
    EQUALITY        shift and go to state 34
    DIFFERENTFROM   shift and go to state 35
    GREATEREQUALSTHAN shift and go to state 36
    LESSEQUALSTHAN  shift and go to state 37

    operador                       shift and go to state 25
    operComp                       shift and go to state 26

state 54

    (37) asignacion -> ID ASSIGN condiciones .

    SEMICOLON       reduce using rule 37 (asignacion -> ID ASSIGN condiciones .)


state 55

    (38) asignacion -> ID ASSIGN expresionAritmetica .

    SEMICOLON       reduce using rule 38 (asignacion -> ID ASSIGN expresionAritmetica .)


state 56

    (39) asignacion -> ID ASSIGN estructuras .

    SEMICOLON       reduce using rule 39 (asignacion -> ID ASSIGN estructuras .)


state 57

    (40) estructuras -> tupla .

    SEMICOLON       reduce using rule 40 (estructuras -> tupla .)


state 58

    (41) estructuras -> array .

    SEMICOLON       reduce using rule 41 (estructuras -> array .)


state 59

    (42) tupla -> LPAREN . valores RPAREN
    (43) tupla -> LPAREN . RPAREN
    (18) valores -> . valor
    (19) valores -> . valor COMMA valores
    (15) valor -> . INTEGER
    (16) valor -> . FLOAT
    (17) valor -> . ID

    RPAREN          shift and go to state 67
    INTEGER         shift and go to state 16
    FLOAT           shift and go to state 17
    ID              shift and go to state 46

    valores                        shift and go to state 66
    valor                          shift and go to state 68

state 60

    (44) array -> LBRACKET . valores RBRACKET
    (45) array -> LBRACKET . RBRACKET
    (18) valores -> . valor
    (19) valores -> . valor COMMA valores
    (15) valor -> . INTEGER
    (16) valor -> . FLOAT
    (17) valor -> . ID

    RBRACKET        shift and go to state 70
    INTEGER         shift and go to state 16
    FLOAT           shift and go to state 17
    ID              shift and go to state 46

    valores                        shift and go to state 69
    valor                          shift and go to state 68

state 61

    (47) estrFor -> FOR ID IN . ID LCURLYBRACKET codigo RCURLYBRACKET

    ID              shift and go to state 71


state 62

    (46) estrWhile -> WHILE condiciones LCURLYBRACKET . codigo RCURLYBRACKET
    (1) codigo -> . expresionAritmetica SEMICOLON
    (2) codigo -> . impresion SEMICOLON
    (3) codigo -> . condiciones SEMICOLON
    (4) codigo -> . asignacion SEMICOLON
    (5) codigo -> . estrFor
    (6) codigo -> . estrWhile
    (7) codigo -> . input SEMICOLON
    (8) expresionAritmetica -> . valor operador valor
    (9) expresionAritmetica -> . valor operador expresionAritmetica
    (20) impresion -> . PRINTLN NOT LPAREN valores RPAREN
    (21) impresion -> . PRINTLN NOT LPAREN valor RPAREN
    (30) condiciones -> . condicion
    (31) condiciones -> . condicion conector condiciones
    (36) asignacion -> . ID ASSIGN valor
    (37) asignacion -> . ID ASSIGN condiciones
    (38) asignacion -> . ID ASSIGN expresionAritmetica
    (39) asignacion -> . ID ASSIGN estructuras
    (47) estrFor -> . FOR ID IN ID LCURLYBRACKET codigo RCURLYBRACKET
    (46) estrWhile -> . WHILE condiciones LCURLYBRACKET codigo RCURLYBRACKET
    (22) input -> . STD DOUBLECOLON IO DOUBLECOLON STDIN LPAREN RPAREN DOT READLINE LPAREN REF MUT ID RPAREN
    (15) valor -> . INTEGER
    (16) valor -> . FLOAT
    (17) valor -> . ID
    (23) condicion -> . valor operComp valor
    (32) condicion -> . TRUE
    (33) condicion -> . FALSE

    PRINTLN         shift and go to state 10
    ID              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    STD             shift and go to state 15
    INTEGER         shift and go to state 16
    FLOAT           shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19

    condiciones                    shift and go to state 4
    codigo                         shift and go to state 72
    expresionAritmetica            shift and go to state 2
    impresion                      shift and go to state 3
    asignacion                     shift and go to state 5
    estrFor                        shift and go to state 6
    estrWhile                      shift and go to state 7
    input                          shift and go to state 8
    valor                          shift and go to state 9
    condicion                      shift and go to state 11

state 63

    (22) input -> STD DOUBLECOLON IO . DOUBLECOLON STDIN LPAREN RPAREN DOT READLINE LPAREN REF MUT ID RPAREN

    DOUBLECOLON     shift and go to state 73


state 64

    (20) impresion -> PRINTLN NOT LPAREN valores . RPAREN

    RPAREN          shift and go to state 74


state 65

    (21) impresion -> PRINTLN NOT LPAREN valor . RPAREN
    (18) valores -> valor .
    (19) valores -> valor . COMMA valores

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 75
    COMMA           shift and go to state 76

  ! RPAREN          [ reduce using rule 18 (valores -> valor .) ]


state 66

    (42) tupla -> LPAREN valores . RPAREN

    RPAREN          shift and go to state 77


state 67

    (43) tupla -> LPAREN RPAREN .

    SEMICOLON       reduce using rule 43 (tupla -> LPAREN RPAREN .)


state 68

    (18) valores -> valor .
    (19) valores -> valor . COMMA valores

    RPAREN          reduce using rule 18 (valores -> valor .)
    RBRACKET        reduce using rule 18 (valores -> valor .)
    COMMA           shift and go to state 76


state 69

    (44) array -> LBRACKET valores . RBRACKET

    RBRACKET        shift and go to state 78


state 70

    (45) array -> LBRACKET RBRACKET .

    SEMICOLON       reduce using rule 45 (array -> LBRACKET RBRACKET .)


state 71

    (47) estrFor -> FOR ID IN ID . LCURLYBRACKET codigo RCURLYBRACKET

    LCURLYBRACKET   shift and go to state 79


state 72

    (46) estrWhile -> WHILE condiciones LCURLYBRACKET codigo . RCURLYBRACKET

    RCURLYBRACKET   shift and go to state 80


state 73

    (22) input -> STD DOUBLECOLON IO DOUBLECOLON . STDIN LPAREN RPAREN DOT READLINE LPAREN REF MUT ID RPAREN

    STDIN           shift and go to state 81


state 74

    (20) impresion -> PRINTLN NOT LPAREN valores RPAREN .

    SEMICOLON       reduce using rule 20 (impresion -> PRINTLN NOT LPAREN valores RPAREN .)


state 75

    (21) impresion -> PRINTLN NOT LPAREN valor RPAREN .

    SEMICOLON       reduce using rule 21 (impresion -> PRINTLN NOT LPAREN valor RPAREN .)


state 76

    (19) valores -> valor COMMA . valores
    (18) valores -> . valor
    (19) valores -> . valor COMMA valores
    (15) valor -> . INTEGER
    (16) valor -> . FLOAT
    (17) valor -> . ID

    INTEGER         shift and go to state 16
    FLOAT           shift and go to state 17
    ID              shift and go to state 46

    valor                          shift and go to state 68
    valores                        shift and go to state 82

state 77

    (42) tupla -> LPAREN valores RPAREN .

    SEMICOLON       reduce using rule 42 (tupla -> LPAREN valores RPAREN .)


state 78

    (44) array -> LBRACKET valores RBRACKET .

    SEMICOLON       reduce using rule 44 (array -> LBRACKET valores RBRACKET .)


state 79

    (47) estrFor -> FOR ID IN ID LCURLYBRACKET . codigo RCURLYBRACKET
    (1) codigo -> . expresionAritmetica SEMICOLON
    (2) codigo -> . impresion SEMICOLON
    (3) codigo -> . condiciones SEMICOLON
    (4) codigo -> . asignacion SEMICOLON
    (5) codigo -> . estrFor
    (6) codigo -> . estrWhile
    (7) codigo -> . input SEMICOLON
    (8) expresionAritmetica -> . valor operador valor
    (9) expresionAritmetica -> . valor operador expresionAritmetica
    (20) impresion -> . PRINTLN NOT LPAREN valores RPAREN
    (21) impresion -> . PRINTLN NOT LPAREN valor RPAREN
    (30) condiciones -> . condicion
    (31) condiciones -> . condicion conector condiciones
    (36) asignacion -> . ID ASSIGN valor
    (37) asignacion -> . ID ASSIGN condiciones
    (38) asignacion -> . ID ASSIGN expresionAritmetica
    (39) asignacion -> . ID ASSIGN estructuras
    (47) estrFor -> . FOR ID IN ID LCURLYBRACKET codigo RCURLYBRACKET
    (46) estrWhile -> . WHILE condiciones LCURLYBRACKET codigo RCURLYBRACKET
    (22) input -> . STD DOUBLECOLON IO DOUBLECOLON STDIN LPAREN RPAREN DOT READLINE LPAREN REF MUT ID RPAREN
    (15) valor -> . INTEGER
    (16) valor -> . FLOAT
    (17) valor -> . ID
    (23) condicion -> . valor operComp valor
    (32) condicion -> . TRUE
    (33) condicion -> . FALSE

    PRINTLN         shift and go to state 10
    ID              shift and go to state 12
    FOR             shift and go to state 13
    WHILE           shift and go to state 14
    STD             shift and go to state 15
    INTEGER         shift and go to state 16
    FLOAT           shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19

    codigo                         shift and go to state 83
    expresionAritmetica            shift and go to state 2
    impresion                      shift and go to state 3
    condiciones                    shift and go to state 4
    asignacion                     shift and go to state 5
    estrFor                        shift and go to state 6
    estrWhile                      shift and go to state 7
    input                          shift and go to state 8
    valor                          shift and go to state 9
    condicion                      shift and go to state 11

state 80

    (46) estrWhile -> WHILE condiciones LCURLYBRACKET codigo RCURLYBRACKET .

    $end            reduce using rule 46 (estrWhile -> WHILE condiciones LCURLYBRACKET codigo RCURLYBRACKET .)
    RCURLYBRACKET   reduce using rule 46 (estrWhile -> WHILE condiciones LCURLYBRACKET codigo RCURLYBRACKET .)


state 81

    (22) input -> STD DOUBLECOLON IO DOUBLECOLON STDIN . LPAREN RPAREN DOT READLINE LPAREN REF MUT ID RPAREN

    LPAREN          shift and go to state 84


state 82

    (19) valores -> valor COMMA valores .

    RPAREN          reduce using rule 19 (valores -> valor COMMA valores .)
    RBRACKET        reduce using rule 19 (valores -> valor COMMA valores .)


state 83

    (47) estrFor -> FOR ID IN ID LCURLYBRACKET codigo . RCURLYBRACKET

    RCURLYBRACKET   shift and go to state 85


state 84

    (22) input -> STD DOUBLECOLON IO DOUBLECOLON STDIN LPAREN . RPAREN DOT READLINE LPAREN REF MUT ID RPAREN

    RPAREN          shift and go to state 86


state 85

    (47) estrFor -> FOR ID IN ID LCURLYBRACKET codigo RCURLYBRACKET .

    $end            reduce using rule 47 (estrFor -> FOR ID IN ID LCURLYBRACKET codigo RCURLYBRACKET .)
    RCURLYBRACKET   reduce using rule 47 (estrFor -> FOR ID IN ID LCURLYBRACKET codigo RCURLYBRACKET .)


state 86

    (22) input -> STD DOUBLECOLON IO DOUBLECOLON STDIN LPAREN RPAREN . DOT READLINE LPAREN REF MUT ID RPAREN

    DOT             shift and go to state 87


state 87

    (22) input -> STD DOUBLECOLON IO DOUBLECOLON STDIN LPAREN RPAREN DOT . READLINE LPAREN REF MUT ID RPAREN

    READLINE        shift and go to state 88


state 88

    (22) input -> STD DOUBLECOLON IO DOUBLECOLON STDIN LPAREN RPAREN DOT READLINE . LPAREN REF MUT ID RPAREN

    LPAREN          shift and go to state 89


state 89

    (22) input -> STD DOUBLECOLON IO DOUBLECOLON STDIN LPAREN RPAREN DOT READLINE LPAREN . REF MUT ID RPAREN

    REF             shift and go to state 90


state 90

    (22) input -> STD DOUBLECOLON IO DOUBLECOLON STDIN LPAREN RPAREN DOT READLINE LPAREN REF . MUT ID RPAREN

    MUT             shift and go to state 91


state 91

    (22) input -> STD DOUBLECOLON IO DOUBLECOLON STDIN LPAREN RPAREN DOT READLINE LPAREN REF MUT . ID RPAREN

    ID              shift and go to state 92


state 92

    (22) input -> STD DOUBLECOLON IO DOUBLECOLON STDIN LPAREN RPAREN DOT READLINE LPAREN REF MUT ID . RPAREN

    RPAREN          shift and go to state 93


state 93

    (22) input -> STD DOUBLECOLON IO DOUBLECOLON STDIN LPAREN RPAREN DOT READLINE LPAREN REF MUT ID RPAREN .

    SEMICOLON       reduce using rule 22 (input -> STD DOUBLECOLON IO DOUBLECOLON STDIN LPAREN RPAREN DOT READLINE LPAREN REF MUT ID RPAREN .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for RPAREN in state 65 resolved as shift
